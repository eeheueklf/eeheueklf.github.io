---
sidebar_position: 3
---

# 인덱스 다루기 (Day 11-12)

:::note
[프로그래머스] <mark>일일 도전 과제 문제 풀이 정리</mark>입니다.  
관련 개념도 첨부하였으니 필요한 분들은 참고하세요.  
**코딩 기초 트레이닝**, **코딩테스트 입문** 문제를 Day별로 풀고 정리한 내용입니다.
:::

:::warning
#### ✨Day 11-12
오늘은 입문, 기초 난이도 비슷함

**목표**: 인덱스를 반환하는 여러 방법
- 배열 순회  
    `forEach` ✨ 각 요소에 대해 함수 실행  
    `map` ✨ 각 요소를 변환해서 새 배열 반환  
    `reduce` ✨ 하나의 누적된 값  
    `filter` ✨ 조건을 통과한 요소만 새 배열 생성  
    
- 2차원 배열 순회와 구조분해할당

새롭게 알아야 할 메서드
- 문자열   
    `charCodeAt` 💟 특정 위치 문자의 아스키 번호 반환  
    `replace` 🔄 문자열에서 첫번째 특정 패턴 치환  
- 배열  
    `findIndex` 🔍 조건을 만족하는 첫번째 요소의 인덱스 반환  
- 문자열/배열  
    `indexOf` 🔍 찾으려는 첫번째 인덱스 반환  
    `lastIndexOf` 🔍 찾으려는 마지막 인덱스 반환  
    `slice` 🔄  문자열/배열 자르기 | 새 문자열/배열 반환

:::


이건 좋은 방법 못찾겠음

코드는 정말 방대하고, 개선점이 많구나. 이번 회차 풀면서 느낌

---
    
## 기초

### 문자 개수 세기

배열 만들기 (길이 맞추기)

```jsx
function solution(my_string) {
    const N = 52;
    let arr;
    (arr = []).length = N;
    arr.fill(0);
    [...my_string].forEach((v,idx)=>{
        v.charCodeAt()<91? arr[v.charCodeAt()-65]++ : arr[v.charCodeAt()-71]++;
    })
    return arr
}
```

**✨개선 코드**
```jsx
function solution(str) {
    return [...str].reduce((p, c) => 
    (p[c.charCodeAt() - (c === c.toLowerCase() ? 71 : 65)]++, p), Array(52).fill(0));
}
```
---
### 글자 지우기

많이 보는 구조!

*기존거에 뭔가 새로운 필터를 거쳐 새로운 배열을 만드는 거 -> filter*

```jsx
function solution(my_string, indices) {
    return [...my_string].filter((_,idx)=> indices.indexOf(idx)===-1).join('')
}
```
---

### 가까운 1 찾기

```jsx
function solution(arr, idx) {
    for(let i=idx;i<arr.length;i++){
        if(arr[i]===1) return i
    }
    return -1
}
```

이 메서드에 대한 문제 
- `indexOf` 문자열/배열 메서드 | 첫번째 인덱스 반환

```jsx
const solution=(a,i)=>a.indexOf(1,i);
```

---
### 첫 번째로 나오는 음수

```jsx
function solution(num_list) {
    for(let i=0;i<num_list.length;i++){
        if(num_list[i]<0) return i;
    }
    return -1;
}
```

**✨개선 코드**
- `findIndex` 매개변수 안에 조건 넣기

```jsx
const solution = num_list => num_list.findIndex(v => v < 0)
```
---
### 리스트 자르기

```jsx
function solution(n, slicer, num_list) {
    switch (n) {
        case 1:
            return num_list.slice(0,slicer[1]+1)
            break;
        case 2:
            return num_list.slice(slicer[0])
            break;
        case 3:
            return num_list.slice(slicer[0],slicer[1]+1)
            break;
        case 4:
            return num_list.slice(slicer[0],slicer[1]+1).filter((_,idx)=> idx%slicer[2]===0)
            break;
    }
}
```

**✨개선 코드**
- `구조분해할당`
```jsx
function solution(n, slicer, num_list) {
    let [a, b, c] = [...slicer];

    switch(n) {
        case 1:
            return num_list.slice(0, b + 1);
        case 2:
            return num_list.slice(a);
        case 3:
            return num_list.slice(a, b + 1);
        case 4:
            return num_list.slice(a, b + 1).filter((_, idx) => !(idx % c));
    }
}
```
---
### 배열 만들기3

배열을 합치는 방법 여러가지 알아보기 
- `concat`
```jsx
function solution(arr, intervals) {
    return arr.slice(intervals[0][0], intervals[0][1]+1)
    .concat(arr.slice(intervals[1][0], intervals[1][1]+1))
}
```

- `스프레드 연산자 ...`
```jsx
function solution(arr, intervals) {
    return [...arr.slice(intervals[0][0], intervals[0][1]+1),
    ...arr.slice(intervals[1][0], intervals[1][1]+1)]
}
```
- `push`
```jsx
function solution(arr, intervals) {
    var answer = [];

    intervals.map((a)=>{
        for(let i = a[0]; i<=a[1]; i++){
            answer.push(arr[i])
        }
    })

    return answer;
}
```
---
### 2의 영역

```jsx
function solution(arr) {
    const tidx = [];
    arr.forEach((v,idx)=> {
        if(v===2) tidx.push(idx)
    })
    return tidx.length>0? arr.slice(tidx[0], tidx[tidx.length-1]+1) : [-1]
}
```

**✨개선 코드**
- `indexOf` 첫번째 인덱스 반환
- `lastIndexOf`  마지막 인덱스 반환

```jsx
function solution(arr) {
    const from = arr.indexOf(2);
    const end = arr.lastIndexOf(2);

    return from === -1 ? [-1] : arr.slice(from, end+1);
}
```
---
### 배열 조각하기

```jsx
function solution(arr, query) {
    query.forEach((v,idx)=>{
        idx%2===0 ?
            arr = arr.slice(0,v+1) :
            arr = arr.slice(v)
    })
    return arr
}
```

---

## 입문

### 주사위의 개수

```jsx
function solution(box, n) {
    return Math.floor(box[0]/n) * Math.floor(box[1]/n) * Math.floor(box[2]/n)
}

```

**✨개선 코드**
- `구조분해 할당`

```jsx
function solution(box, n) {
    let [width, length, height] = box;

    return Math.floor(width / n) * Math.floor(length / n) * Math.floor(height / n);
}
```
---
### 합성수 찾기

```jsx
function solution(n) {
    let fl = 0;
    for(let i=2;i<=n;i++){
        for(let j=2;j<i;j++){
            if(i%j===0){
                fl++;
                break;
            }
        }      
    }
    return fl;
}
```
---
### 모음제거

```jsx
function solution(my_string) {
    const vowels = ['a', 'e', 'i', 'o', 'u'];
    return [...my_string].filter((v,idx)=> vowels.indexOf(v)===-1).join('')
}
```

**✨개선 코드**
- `정규식` : `a,e,i,o,u` 중 하나인 문자를 전역`g`으로 찾음

```jsx
function solution(my_string) {
    return my_string.replace(/[aeiou]/g, '');
}

```
---
### 문자열 정렬1

```jsx
function solution(my_string) {
    return [...my_string].filter((v,idx)=> !isNaN(v)).map(v=>Number(v)).sort((a,b)=> a-b)
}
```

**✨개선 코드**
- `정규식`
- `replace`

```jsx
function solution(my_string) {
    return my_string.replace(/[^\d]/g,'').split('').map(v=>+v).sort();
}
```
---
### 숨어있는 숫자의 덧셈

```jsx
function solution(my_string) {
    return [...my_string.replace(/[^\d]/g,'')].reduce((acc,val)=> acc+Number(val),0)
}
```
---
### 소인수 분해

```jsx
function divid(n, i){
    if(n%i!==0) return 1;
    return i * divid(n/i, i)
}

function solution(n) {
    const answer = [];
    for(let i=2;i<=n;i++){
        if(n%i===0){
            answer.push(i);
            n = n / divid(n, i);
        }
    }
    return answer;
}
```

**✨개선 코드**
- `Set`
```jsx
function solution(n) {
    let answer = []

    let i = 2;
    while (i <= n) {
      if (n % i === 0) {
        answer.push(i)     
        n = n / i
      } else {
      i++        
      }
    }

    return [...new Set(answer.sort((a, b) => a > b ? 1 : -1))]
}
```