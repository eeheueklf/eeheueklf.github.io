---
sidebar_position: 3
---

# filter() 활용 예제 문제 (Day 13-14)

:::note
[프로그래머스] <mark>일일 도전 과제 문제 풀이 정리</mark>입니다.  
관련 개념도 첨부하였으니 필요한 분들은 참고하세요.  
**코딩 기초 트레이닝**, **코딩테스트 입문** 문제를 Day별로 풀고 정리한 내용입니다.
:::

:::warning
#### ✨Day 13-14
**목표**:오늘은 filter() 쓸 수 있는 문제가 많다. 적용해가면서 익혀보자.

- `filter` ✨✨ 배열 순회 메서드 | 조건을 통과한 요소만 새 배열 생성  
    `array.filter((v,idx)=> v%2===0)`
    
- `slice(begin, end)` 💕 배열 자르기 메서드 | 복사본 생성, 원본 배열 유지
- `indexOf` 💭 문자열/배열 메서드 | 첫번째 인덱스 반환
:::

---
    
## 입문

### 컨트롤제트

*각 원소에 대한 부가적인 실행 → forEach*

값이 Z라면 이전 원소를 빼자.

```jsx
function solution(s) {
    let sum = 0, prev;
    s.split(' ').forEach((v,idx)=>{
        v==='Z'? sum-=prev : sum+=Number(v); prev=Number(v);
    })
    return sum
}
```

**✨개선코드**

여러 배열 순회 메서드를 활용해서 구현해보았다

- `map` 다음 값이 Z면 현재값 Z로 바꾸기
- `filter` 배열에서 Z 빼기
- `reduce` 누적합

```jsx
function solution(s) {
    return s.split(' ')
    .map((v,idx,arr)=> arr[idx+1] === 'Z' ? 'Z' : v)
    .filter((v)=> v!=='Z')
    .reduce((acc, cur) => acc + Number(cur), 0)
}
```
---
### 배열 원소의 길이

각 원소의 길이를 담은 배열

*각 원소에 대한 변환 → map*
```jsx
function solution(strlist) {
    return strlist.map((v) => v.length)
}
```
---
### 중복된 문자 제거

indexOf 하면 첫 번째 index나오는데 일치하는 것만 반환하기

*각 요소에 대한 조건문 → filter*

```jsx
function solution(my_string) {
    return [...my_string].filter((v,idx,arr) => arr.indexOf(v)===idx).join('')
}
```

**✨다른 코드**

string을 배열화 → set에 저장(중복 방지) → join

```jsx
function solution(my_string) {
    return [...new Set(my_string)].join('');
}
```
---
### 삼각형의 완성조건(1)

- `구조분해 할당` 해보기

```jsx
function solution(sides) {
    sides.sort((a,b)=>a-b)
    const [a,b,c] = sides;
    return a + b > c ? 1 : 2
}
```
---
### 가까운 수

n과 차가 가장 작은 수를 return

*각 원소를 n과의 차(절댓값)으로 변환 → map*
- `Math.min`
- `indexOf`

```jsx
function solution(array, n) {
    let diff = Math.min(...array.map((v)=>Math.abs(v-n)))
    return array.indexOf(n-diff)!==-1 ? n-diff : n+diff
}
```
---
### 369게임

- `filter` 로 3배수만 잘라서 length 하기!

<mark> 0 도 나 머 지 가 0 이 다</mark>

```jsx
function solution(order) {
    return [...String(order)].map(Number).filter((v)=> v!==0 && v%3===0).length
}
```

**✨신기한 코드**

- `split` 기준을 369로 해서 분리, length 구하기

```jsx
function solution(order) {
    return (''+order).split(/[369]/).length-1;
}
```
---

### 암호 해독

code의 배수번째 글자만 암호이다

*조건문 code로 암호 거르기 → filter*

```jsx
function solution(cipher, code) {
    return [...cipher].filter((_,idx)=> idx%(code)===code-1).join('')
}
```

---
### 대문자와 소문자

대문자는 소문자로 소문자는 대문자로

*→ 당연히 map*

```jsx
function solution(my_string) {
    return [...my_string].map((v) => v.toUpperCase()===v? v.toLowerCase() : v.toUpperCase()).join('')
}
```

---

## 기초

### n번째 원소부터

*원소 보고 거르니까 filter*

```jsx
function solution(num_list, n) {
    return num_list.filter((_,idx)=> idx+1>=n)
}
```

이런 느낌쓰도 가능

```jsx
function solution(num_list, n) {
  return num_list.slice(n - 1);
}
```

---
### 순서 바꾸기

배열 합치는 방법 중 `스프레드 연산자 ...`

```jsx
function solution(num_list, n) {
    return [...num_list.slice(n), ...num_list.slice(0,n)]
}
```

---
### 왼쪽 오른쪽

조건문으로 자름

```jsx
function solution(str_list) {
    let l = str_list.indexOf('l');
    let r = str_list.indexOf('r');
    if(l*r === 1) return [];
    if(l === -1) return str_list.slice(r+1);
    if(r === -1) return str_list.slice(0,l);
    return l < r ? str_list.slice(0,l) : str_list.slice(r+1)
}

```

**✨신기한 코드**

순회하면서 자르기!

```jsx
function solution(arr) {
    for(let i = 0; i < arr.length; i++) {
        if (arr[i] === 'l') return arr.slice(0, i);
        if (arr[i] === 'r') return arr.slice(i + 1);
    }
    return [];
}
```

---
### n개 간격의 원소들

*원소 거르는거 ⇒ filter*

```jsx
function solution(num_list, n) {
    return num_list.filter((_,idx)=> idx%n===0)
}
```

---
### 홀수 vs 짝수

*누산기 ⇒ reduce*  
*할라했는데 이게 값이 두개가 나옴 → forEach*

```jsx
function solution(num_list) {
    let sumO=0, sumE=0;
    num_list.forEach((v,idx) => idx%2===0 ? sumE += v : sumO += v)
    return sumO > sumE ? sumO : sumE
}
```

Math.max써도됨

---
### 2명씩

*각 원소 거르기 → filter*

```jsx
function solution(names) {
    return names.filter((_,idx) => idx%5===0)
}
```

---
### 할 일 목록

*각 원소 거르기 → filter*

```jsx
function solution(todo_list, finished) {
    return todo_list.filter((_,idx) => !finished[idx])
}
```

---
### n보다 커질때까지 더하기

*누적값 → reduce*

```jsx
function solution(numbers, n) {
    return numbers.reduce((acc,cur) => acc<=n ? acc + cur : acc)
}
```

---
### 수열과 구간 쿼리1

```jsx
function solution(arr, queries) {
    queries.forEach(([s,e]) => {
        for(let i=s;i<=e;i++) arr[i]++;
    })
    return arr
}
```

for 대신 while도 가능