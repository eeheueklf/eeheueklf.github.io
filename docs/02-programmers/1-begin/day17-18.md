---
sidebar_position: 3

draft: true
---

# ë¬¸ìì—´ íŠ¸ë ˆì´ë‹ (Day 17-18)

:::note
[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] <mark>ì¼ì¼ ë„ì „ ê³¼ì œ ë¬¸ì œ í’€ì´ ì •ë¦¬</mark>ì…ë‹ˆë‹¤.  
ê´€ë ¨ ê°œë…ë„ ì²¨ë¶€í•˜ì˜€ìœ¼ë‹ˆ í•„ìš”í•œ ë¶„ë“¤ì€ ì°¸ê³ í•˜ì„¸ìš”.  
**ì½”ë”© ê¸°ì´ˆ íŠ¸ë ˆì´ë‹**, **ì½”ë”©í…ŒìŠ¤íŠ¸ ì…ë¬¸** ë¬¸ì œë¥¼ Dayë³„ë¡œ í’€ê³  ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.
:::

:::warning
#### âœ¨Day 17-18
ì˜¤ëŠ˜ë„ ë¬¸ìì—´ ê´€ë ¨ ì˜ˆì œë“¤ì´ ë§ìŠµë‹ˆë‹¤

**ëª©í‘œ**: ë¬¸ìì—´ ì¹˜í™˜í•˜ê¸° & ì •ê·œì‹ ìµíˆê¸°
    
- ë°°ì—´ ìˆœíšŒ  
    `reduce` âœ¨ í•˜ë‚˜ì˜ ëˆ„ì ëœ ê°’  
    `filter` âœ¨ ì¡°ê±´ì„ í†µê³¼í•œ ìš”ì†Œë§Œ ìƒˆ ë°°ì—´ ìƒì„±  
- êµ¬ì¡°ë¶„í•´í• ë‹¹

ì•Œì•„ì•¼ í•  ë©”ì„œë“œ
- íƒìƒ‰/í™•ì¸  
    `includes` ğŸ” ë°°ì—´ì— ê°’ ì¡´ì¬ ì—¬ë¶€ í™•ì¸  
    `lastIndexOf` ğŸ” ì°¾ìœ¼ë ¤ëŠ” ë¬¸ìì—´ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ ë°˜í™˜  
    `match()` ğŸ” ë¬¸ìì—´ì´ ëª‡ ë²ˆ ë“±ì¥í•˜ëŠ”ì§€ ì„¸ê¸°
- ë¬¸ìì—´ ì¹˜í™˜/ë³€í™˜  
    `replaceAll` ğŸ”„ ë¬¸ìì—´ì—ì„œ ëª¨ë“  íŠ¹ì • íŒ¨í„´ ì¹˜í™˜ 
- ì •ê·œì‹    
    `/zero|one|two|.../g` : OR íŒ¨í„´, ì „ì—­ ì¹˜í™˜  
    `new RegExp(str,'g')` : ë¬¸ìì—´ ë™ì  íŒ¨í„´
:::

---
    
## ì…ë¬¸

### ìˆ«ì ì°¾ê¸°

```jsx
function solution(num, k) {
    return (num+"").indexOf(k)+1 || -1
}
```
ğŸ `(num+"")` Number -> String



---

### nì˜ ë°°ìˆ˜ ê³ ë¥´ê¸°

```jsx
function solution(n, numlist) {
    return numlist.filter((v)=> !(v%n))
}
```
ğŸ `filter`

---

### ìë¦¿ìˆ˜ ë”í•˜ê¸°

```jsx
function solution(n) {
    return [...(n+"")].reduce((acc,cur)=> acc + Number(cur), 0)
}
```

```jsx
function solution(n) {
  return n
    .toString()
    .split("")
    .reduce((acc, cur) => acc + Number(cur), 0);
}
```

---

### OXí€´ì¦ˆ

```jsx
function solution(quiz) {
    return quiz.map((v)=> {
        const [form,result] = v.split('=');
        const [a, op, b] = form.split(' ');
        const sum = op === '+' ? Number(a) + Number(b) : Number(a) - Number(b);
        return sum === Number(result) ? 'O' : 'X'
    })
}
```
ğŸ `êµ¬ì¡°ë¶„í•´í• ë‹¹`

---

### ë¬¸ìì—´ì•ˆì— ë¬¸ìì—´

```jsx
function solution(str1, str2) {
    return str1.includes(str2) ? 1 : 2
}
```

ğŸ `includes`

```jsx
function solution(str1, str2) {
    return str1.split(str2).length > 1 ? 1 : 2
}
```
ğŸ `split`ì˜ ë‹¤ë¥¸ ì“°ì„ìƒˆ


---

### ì œê³±ìˆ˜ íŒë³„í•˜ê¸°

```jsx
function solution(n) {
    let i = 1;
    while(i*i<=n){
        if(i*i===n) return 1;
        i++;
    }
    return 2;
}
```

```jsx
function solution(n) {
  return Number.isInteger(Math.sqrt(n)) ? 1 : 2;
}
```
ğŸ `sqrt`ë¡œ ì œê³±ê·¼ êµ¬í•˜ê³  `isInteger` ì •ìˆ˜ì¸ì§€ í™•ì¸

---

### ì„¸ê·  ì¦ì‹

```jsx
function solution(n, t) {
    for(let i=0;i<t;i++){
        n *= 2
    }
    return n
}
```

```jsx
function solution(n, t) {
  return n << t;
}
```

ğŸ `ì‹œí”„íŠ¸ì—°ì‚°` `n<<t`ëŠ” `n*2^t`

---

### ë¬¸ìì—´ ì •ë ¬í•˜ê¸° (2)

```jsx
function solution(my_string) {
    return [...my_string.toLowerCase()].sort().join('')
}
```

---

## ê¸°ì´ˆ

### íŠ¹ì • ë¬¸ìì—´ë¡œ ëë‚˜ëŠ” ê°€ì¥ ê¸´ ë¶€ë¶„ ë¬¸ìì—´ ì°¾ê¸°

```jsx
function solution(myString, pat) {
    return myString.slice(0,myString.lastIndexOf(pat)+pat.length)
}
```

---

### ë¬¸ìì—´ì´ ëª‡ ë²ˆ ë“±ì¥í•˜ëŠ”ì§€ ì„¸ê¸°

```jsx
function solution(myString, pat) {
    return [...myString].filter((_,idx)=>myString.slice(idx,idx+pat.length)
        .includes(pat)).length
}
```

```jsx
function solution(myString, pat) {
    const reg = new RegExp(`(?=${pat})`, "g")
    return myString.match(reg)?.length || 0;
}
```

ğŸ `ì •ê·œì‹`

---

### ad ì œê±°í•˜ê¸°

```jsx
function solution(strArr) {
    return strArr.filter((v)=> !v.includes('ad'))
}
```

---

### ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 2

```jsx
function solution(my_string) {
    return my_string.split(' ').filter((v) => v!=='')
}
```

ğŸ `filter(v=>v)`ë„ ë¨ : JSì—ì„œ ""ëŠ” falsy ê°’ì´ê¸° ë•Œë¬¸

---

### x ì‚¬ì´ì˜ ê°œìˆ˜

```jsx
function solution(myString) {
    return myString.split('x').map((v)=>v.length)
}
```

---

### ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°

```jsx
function solution(binomial) {
    const [a, op, b] = binomial.split(' ')
    switch (op){
        case '+':
            return Number(a) + Number(b);
        case '-':
            return Number(a) - Number(b);
        case '*':
            return Number(a) * Number(b)
    }
}
```
ğŸ `êµ¬ì¡°ë¶„í•´í• ë‹¹`

```jsx
const ops = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
};

function solution(binomial) {
  const [a, op, b] = binomial.split(' ');
  return ops[op](+a, +b);
}
```
ğŸ `ê°ì²´`

---

### rny_string

```jsx
function solution(rny_string) {
    return [...rny_string].map((v)=> v==='m'?'rn':v).join('')
}
```

```jsx
function solution(rny_string) {
    return rny_string.replaceAll(/m/g, "rn");
}
```
ğŸ `ì •ê·œì‹`