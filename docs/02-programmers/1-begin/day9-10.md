---
sidebar_position: 2
---


# Day 9-10 | 문자열 배열 자르기 substr slice splice

:::note
[프로그래머스] <mark>일일 도전 과제 문제 풀이 정리</mark>입니다.  
관련 개념도 첨부하였으니 필요한 분들은 참고하세요.  
**코딩 기초 트레이닝**, **코딩테스트 입문** 문제를 Day별로 풀고 정리한 내용입니다.
:::

:::warning
#### ✨Day 9-10
오늘은 입문, 기초 난이도 비슷함

**목표**: 문자열과 배열을 잘라보자
- `forEach` ✨ 배열 순회 메서드 | 각 요소에 대해 부가적인 실행    
    `array.map((v,idx)=> console.log(v))`
    
- `map` ✨ 배열 순회 메서드 | 각 요소를 변환해서 새 배열 반환    
    `array.map((v,idx)=> Number(v))`
    
- `reduce` ✨ 배열 순회 메서드 | 하나의 누적된 값    
    `array.reduce((acc,cur)=> acc + cur)`
    
- `filter` ✨✨ 배열 순회 메서드 | 조건을 통과한 요소만 새 배열 생성    
    `array.filter((v,idx)=> v%2===0)`
    
- 2차원 배열 순회와 구조분해할당
- `substr(begin, 길이)` 🔄 문자열 자르기 | 일정 길이로 문자열 자르기
- `slice(begin, end)` 🔄  문자열/배열 자르기 | 새 문자열/배열 반환
- `splice(begin, end)` ❇️ 배열 요소 삭제/추가 | 원본 배열 변경  
:::

---
    
## 입문

### 개미군단

각 구간에 맞는 개미 수 return

```jsx
function solution(hp) {
    const left = hp%5;
    const coef = Math.floor(hp/5);
    
    if(left%3===0) return coef + left/3;
    if(left%3===1) return coef-1 + (left+5)/3;
    if(left%3===2) return coef-2 + (left+10)/3;
}

```

**✨개선 코드**

1이 있기 때문에 굳이 구간을 안 나눠도 hp%5값을 만들 수 있음

- `Math.floor` 소수점 버리기

```jsx

function solution(hp) {
    return Math.floor(hp/5) + Math.floor((hp%5)/3) + (hp%5)%3;
}
```
---

### 모스부호 1

문자열 letter를 공백기준으로 분리하고 배열 돌면서 v를 morse[v]로 변환

*letter의 각 원소를 변환하기 때문에 map 사용*

- `split()` 문자열 → 배열
- `map` 배열 순회
- `join()` 배열 → 문자열

```jsx
function solution(letter) {
    const morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
    };
    return letter.split(' ').map(v => morse[v]).join('')
}
```

**✨개선 코드**

- `map` + `join()`을 `reduce`로 한번에

```jsx
morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
}

function solution(letter) {
    return letter.split(' ').reduce((acc, cur) => acc + morse[cur], '')
}
```
---

### 가위바위보

*rsp의 각 원소를 변환하기 때문에 map 사용*

- 3항연산자

```jsx
function solution(rsp) {
    return [...rsp].map((v) => v==='2' ? '0' : v==='0' ? '5' : '2').join('')
}
```

**✨개선 코드**

- `객체` 키 값으로 대응하는 게 있으면 객체 사용
- `map`

```jsx
function solution(rsp) {
    let arr = {
        2: 0,
        0: 5,
        5: 2
    };
    var answer = [...rsp].map(v => arr[v]).join("");
    return answer;
}
```
---

### 점의 위치 구하기

- `삼항연산자`

```jsx
function solution(dot) {
    return dot[0]*dot[1]>0 ? 
            dot[0]>0 ? 1 : 3 :
            dot[0]>0 ? 4 : 2
}
```

**✨개선 코드**

- `구조분해할당`

```jsx
function solution(dot) {
    const [num,num2] = dot;
    const check = num * num2 > 0;
    return num > 0 ? (check ? 1 : 4) : (check ? 3 : 2);
}
```
---

### 2차원으로 만들기

- `forEach`
- 배열에 `push`

```jsx
function solution(num_list, n) {
    var answer = [];
    let mini = [];
    num_list.forEach((v,idx)=>{
        if(idx%n===0){
            for(let i=0;i<n;i++)
                mini.push(num_list[idx+i])
            answer.push(mini)
            mini = []
        }
    })
    return answer;
}
```

**✨개선 코드**

- `splice` 원본 배열 수정

```jsx
function solution(num_list, n) {
    var answer = [];

    while(num_list.length) {
        answer.push(num_list.splice(0,n));
    }

    return answer;
}

```
---

### 배열회전

- 삼항연산자
- `slice`

```jsx
function solution(numbers, direction) {
    return direction==="right" ? 
        [numbers[numbers.length - 1], ...numbers.slice(0, numbers.length-1)]
    : [...numbers.slice(1), numbers[0]]
}
```

---

## 기초

### 배열만들기 5

*intStrs의 각 원소에 대한 부가적인 실행 → forEach*

- 각 원소를 부분문자열로 자르기
- 자른 값이 k보다 큰 값을 담은 배열 return

```jsx
function solution(intStrs, k, s, l) {
    const answer = []
    intStrs.forEach((v)=>{
        let num = Number(v.substr(s,l))
        if(num>k) answer.push(num)
    })
    return answer;
}
```

**✨개선 코드**

*각 역할이 map과 filter로 대체 가능!*

- 각 원소를 부분문자열로 자르기 → `map`
- 자른 값이 k보다 큰 값을 담은 배열 return → `filter`

```jsx
function solution(intStrs, k, s, l) {
    return intStrs.map((v) => +v.slice(s, s + l)).filter((v) => v > k);
}

```
---

### 부분문자열 이어 붙여 문자열 만들기

*parts의 각 원소를 변환하기 때문에 map 사용*

```jsx
function solution(my_strings, parts) {
    let i=0;
    return parts.map(([s,e])=> my_strings[i++].slice(s,e+1)).join('')
}
```

**✨개선 코드**

**map의 2차원 배열 순회법 ++ (구조분해할당)**

똑같이 idx 쓸 수 있다

```jsx
function solution(my_strings, parts) {
    return parts.map(([s, e], idx) => {
        return my_strings[idx].slice(s, e + 1)
    }).join('')
}
```
---

### 세로 읽기

*my_string의 각 원소를 변환하기 때문에 map 사용*

```jsx
function solution(my_string, m, c) {
    return [...my_string].map((v,idx)=> idx%m===(c-1)? v : '').join('')
}
```

**✨개선 코드**

- `filter` 사용하여 조건에 맞는 원소만 return

```jsx

function solution(my_string, m, c) {
    return [...my_string].filter((_, i) => i % m === c - 1).join('');
}
```
---

### QR코드

조건에 맞는 원소만 return하기 때문에 filter 사용

```jsx
function solution(q, r, code) {
    return [...code].filter((_,idx)=> idx%q===r).join('')
}
```