---
sidebar_position: 3
---

# Day 11-12 | 인덱스 - indexOf findIndex charCodeAt

:::note
[프로그래머스] <mark>일일 도전 과제 문제 풀이 정리</mark>입니다.  
관련 개념도 첨부하였으니 필요한 분들은 참고하세요.  
**코딩 기초 트레이닝**, **코딩테스트 입문** 문제를 Day별로 풀고 정리한 내용입니다.
:::

:::warning
#### ✨Day 11-12
오늘은 입문, 기초 난이도 비슷함

**목표**: 인덱스를 반환하는 여러 방법
- `forEach` ✨ 배열 순회 메서드 | 각 요소에 대해 부가적인 실행
    
    `array.map((v,idx)=> console.log(v))`
    
- `map` ✨ 배열 순회 메서드 | 각 요소를 변환해서 새 배열 반환
    
    `array.map((v,idx)=> Number(v))`
    
- `reduce` ✨ 배열 순회 메서드 | 하나의 누적된 값
    
    `array.reduce((acc,cur)=> acc + cur)`
    
- `filter` ✨✨ 배열 순회 메서드 | 조건을 통과한 요소만 새 배열 생성
    
    `array.filter((v,idx)=> v%2===0)`
    
- 2차원 배열 순회와 구조분해

새롭게 알아야 할 메서드

- `slice(begin, end)` 💕 배열 자르기 메서드 | 복사본 생성, 원본 배열 유지
- `findIndex` ✨ 배열 순회 메서드 | 조건을 만족하는 첫번째 요소의 인덱스 반환
- `charCodeAt` 💭 문자열 메서드 | 특정 위치 문자의 아스키 번호
- `replace` 💭 문자열 메서드 | 검색한 부분을 새 문자열로
- `indexOf` 💭 문자열/배열 메서드 | 첫번째 인덱스 반환
- `lastIndexOf` 💭 문자열/배열 메서드 | 마지막 인덱스 반환
:::

---
    
## 기초

### 문자 개수 세기

배열 만들기 (길이 맞추기)

```jsx
function solution(my_string) {
    const N = 52;
    let arr;
    (arr = []).length = N;
    arr.fill(0);
    [...my_string].forEach((v,idx)=>{
        v.charCodeAt()<91? arr[v.charCodeAt()-65]++ : arr[v.charCodeAt()-71]++;
    })
    return arr
}
```

```jsx
function solution(str) {
    return [...str].reduce((p, c) => (p[c.charCodeAt() - (c === c.toLowerCase() ? 71 : 65)]++, p), Array(52).fill(0));
}
```

### 글자 지우기

많이 보는 구조

기존거에 뭔가 새로운 필터를 거쳐 새로운 배열을 만드는 그런거는 filter

```jsx
function solution(my_string, indices) {
    return [...my_string].filter((_,idx)=> indices.indexOf(idx)===-1).join('')
}
```

### 가까운 1 찾기

```jsx
function solution(arr, idx) {
    for(let i=idx;i<arr.length;i++){
        if(arr[i]===1) return i
    }
    return -1
}
```

이 메서드에 대한 문제 

```jsx
const solution=(a,i)=>a.indexOf(1,i);

```

### → 첫 번째로 나오는 음수

```jsx
function solution(num_list) {
    for(let i=0;i<num_list.length;i++){
        if(num_list[i]<0) return i;
    }
    return -1;
}
```

findIndex 매개변수 안에 조건 넣기

```jsx
const solution = num_list => num_list.findIndex(v => v < 0)
```

### 리스트 자르기

```jsx
function solution(n, slicer, num_list) {
    switch (n) {
        case 1:
            return num_list.slice(0,slicer[1]+1)
            break;
        case 2:
            return num_list.slice(slicer[0])
            break;
        case 3:
            return num_list.slice(slicer[0],slicer[1]+1)
            break;
        case 4:
            return num_list.slice(slicer[0],slicer[1]+1).filter((_,idx)=> idx%slicer[2]===0)
            break;
    }
}
```

```jsx
function solution(n, slicer, num_list) {
    let [a, b, c] = [...slicer];

    switch(n) {
        case 1:
            return num_list.slice(0, b + 1);
        case 2:
            return num_list.slice(a);
        case 3:
            return num_list.slice(a, b + 1);
        case 4:
            return num_list.slice(a, b + 1).filter((_, idx) => !(idx % c));
    }
}
```

### 배열 만들기3

배열을 합치는 방법

```jsx
function solution(arr, intervals) {
    return arr.slice(intervals[0][0], intervals[0][1]+1).concat(arr.slice(intervals[1][0], intervals[1][1]+1))
}
```

```jsx
function solution(arr, intervals) {
    return [...arr.slice(intervals[0][0], intervals[0][1]+1), ...arr.slice(intervals[1][0], intervals[1][1]+1)]
}
```

```jsx
function solution(arr, intervals) {
    var answer = [];

    intervals.map((a)=>{
        for(let i = a[0]; i<=a[1]; i++){
            answer.push(arr[i])
        }
    })

    return answer;
}
```

### 2의 영역

```jsx
function solution(arr) {
    const tidx = [];
    arr.forEach((v,idx)=> {
        if(v===2) tidx.push(idx)
    })
    return tidx.length>0? arr.slice(tidx[0], tidx[tidx.length-1]+1) : [-1]
}
```

new 메서드

```jsx
function solution(arr) {
    const from = arr.indexOf(2);
    const end = arr.lastIndexOf(2);

    return from === -1 ? [-1] : arr.slice(from, end+1);
}
```

### 배열 조각하기

```jsx
function solution(arr, query) {
    query.forEach((v,idx)=>{
        idx%2===0 ?
            arr = arr.slice(0,v+1) :
            arr = arr.slice(v)
    })
    return arr
}
```

---

## 입문

### 주사위의 개수

```jsx
function solution(box, n) {
    return Math.floor(box[0]/n) * Math.floor(box[1]/n) * Math.floor(box[2]/n)
}

```

구조분해 할당

```jsx
function solution(box, n) {
    let [width, length, height] = box;

    return Math.floor(width / n) * Math.floor(length / n) * Math.floor(height / n);
}
```

### 합성수 찾기

```jsx
function solution(n) {
    let fl = 0;
    for(let i=2;i<=n;i++){
        for(let j=2;j<i;j++){
            if(i%j===0){
                fl++;
                break;
            }
        }      
    }
    return fl;
}
```

이건 좋은 방법 못찾겠음

코드는 정말 방대하고, 개선점이 많구나. 이번 회차 풀면서 느낌

### 모음제거

```jsx
function solution(my_string) {
    const vowels = ['a', 'e', 'i', 'o', 'u'];
    return [...my_string].filter((v,idx)=> vowels.indexOf(v)===-1).join('')
}
```

정규표현식

```jsx
function solution(my_string) {
    return my_string.replace(/[aeiou]/g, '');
}

```

### 문자열 정렬1

```jsx
function solution(my_string) {
    return [...my_string].filter((v,idx)=> !isNaN(v)).map(v=>Number(v)).sort((a,b)=> a-b)
}
```

이전 문제 처럼 replace 쓰기

```jsx
function solution(my_string) {
    return my_string.replace(/[^\d]/g,'').split('').map(v=>+v).sort();
}
```

### 숨어있는 숫자의 덧셈

```jsx
function solution(my_string) {
    return [...my_string.replace(/[^\d]/g,'')].reduce((acc,val)=> acc+Number(val),0)
}
```

### 소인수 분해

```jsx
function divid(n, i){
    if(n%i!==0) return 1;
    return i * divid(n/i, i)
}

function solution(n) {
    const answer = [];
    for(let i=2;i<=n;i++){
        if(n%i===0){
            answer.push(i);
            n = n / divid(n, i);
        }
    }
    return answer;
}
```

```jsx
function solution(n) {
    let answer = []

    let i = 2;
    while (i <= n) {
      if (n % i === 0) {
        answer.push(i)     
        n = n / i
      } else {
      i++        
      }
    }

    return [...new Set(answer.sort((a, b) => a > b ? 1 : -1))]
}
```